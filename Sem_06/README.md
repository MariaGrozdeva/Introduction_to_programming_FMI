# Масиви с фиксирана дължина

Масивът представлява последователност от фиксиран брой елементи от един и същ тип, обединени с едно име. Отделен елемент на масива се достъпва посредством името му, последвано от поредния номер (индекс) на елемента, заграден в квадратни скоби.

## Декларация и инициализация на масиви
```c++
int arr[10]; // creates an array of size 10 with random values
int arr[8] = { 10, 20, 33, 44, 50, 60, 7, 8 }; // declares an array of size 8 and initializes it
int arr[5] = { 10, 20 }; // arr[0] == 10, arr[1] == 20, arr[2] == arr[3] == arr[4] == 0

int arr[] // error: storage size of ‘arr’ isn’t known
int arr[4] = { 1, 2, 3, 4, 5 }; // error: too many initializers for ‘int [4]’
```

:bangbang: Задължително големината на масива трябва да е константа, чиято стойност е известна **по време на компилация**.
```c++
size_t n;
cin >> n;
int arr[n]; // error!

constexpr size_t SIZE = 4;
int arr[SIZE]; // ok!
 ```

## Достъп до елемент на масив
Едно от най- големите предимства на масивите е това, че в тях имаме *константен достъп до всеки един елемент*.  
Този достъп се осъществява посредством индекси. ***Индексацията започва от 0***. Защо?  

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_06/images/Array.png)

```c++
int arr[] = { 5, 23, 24, 22 }

cout << arr[2]; // prints the element at index 2 (24)
arr[3] = 44; // arr = { 5, 23, 24, 44 }
cin >> arr[3];
```
Името на масива (arr) представлява **указател към първия му елемент**. Това означава, че ако се опитаме да отпечатаме arr, ще видим шестнайсетично число, което е адресът на първия елемент от масива.
```c++
int arr[] = { 5, 23, 24, 22 }
cout << arr; // 0x7ffd9bc35d90
```

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_06/images/ArrayIndices.jpeg)

## Масив като параметър на функция
:bangbang: Масивите се подават във функциите по адрес. Това означава, че промените, които се извършват върху масива във функцията, ще се отразят върху подадения като аргумент масив.
```c++
#include <iostream>
using namespace std;
 
void print(const int arr[], const size_t len)
{
    for (size_t i = 0; i < len; i++)
    {
        cout << arr[i] << ' ';
    }
}
void increment(int arr[], const size_t len)
{
    for (size_t i = 0; i < len; i++)
    {
        arr[i]++;
    }
}

int main()
{
    constexpr size_t SIZE = 4;
    int arr[SIZE] = { 1, 2, 3, 4 };
 
    increment(arr, SIZE);
    print(arr,SIZE);
}
```

---

## Примери
- Линейно търсене в масив
- Двоично търсене в масив
- Обръщане на масив
- Решето на Ератостен  
![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_06/images/Eratosthenes.gif)

---

## Задачи

**Задача 1:** Напишете функция, която приема масив и елемент и връща индекса на първото срещане на елемента в масива, ако има такова, и -1, в противен случай.  
*Вход: 17 23 5 -14 0 &nbsp;&nbsp; -14, Изход: 3  
Вход: 17 23 5 8 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -14, Изход: -1*  

**Задача 2:** Напишете функция, която приема **сортиран** масив и елемент и връща индекса на елемента в масива, ако има такъв, и -1, в противен случай.  
*Вход: -8 5 22 23 44 100 &nbsp;&nbsp; -8, Изход: 0  
Вход: -8 5 22 23 44 100 &nbsp;&nbsp; 101, Изход: -1*  

**Задача 3:** Напишете функция, която намира най- малкия липсващ елемент в **сортиран** масив от **последователни** числа.  

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_06/images/SmallestMissingElement.png)

**Задача 4:** Ще казваме, че поредица от числа е **трион**, ако всяко число в нея е едновременно по- голямо или равно на двата си съседа или едновременно по- малко или равно на тях.  
За първия и последния елемент имаме само по един съсед.  
Напишете функция, която приема масив от цели числа и ги пренарежда така, че да образуват поредица трион.  
*Вход: 1 5 1 0 3, Изход: 1 5 0 3 1  
Вход: 10 -10 -22 11 18, Изход: 10 -22 11 -10 18*  

**Задача 5:** Напишете функция, която намира най- дългия подмасив, съставен от еднакви числа (подмасивът се определя чрез индексите на началото и края си).  
(Ако най- дългият подмасив не е уникален, да се изведат индексите на първия такъв.)  
*Вход: -8 22 22 22 44 44 -8 100 -8 -8, Изход: 1 3 (22 22 22)  
Вход: 5 5 6 6 7 7 8 8, Изход: 0 1 (5 5)  
Вход: 1 2 3 4 5, Изход: 0 0 (1)*  

**Задача 6:** Въвежда се число k.  
Да се напише функция, която проверява дали в подаден масив съществува подмасив, чиито елементи имат сума, равна на k. Ако има, да се изведат индексите на първия и последния елемент от подмасива.  В противен случай, да се изведе подходящо съобщение.  
*Вход: 17 23 5 -14 0 &nbsp;&nbsp; -9, Изход: yes  
Вход: 17 23 5 8 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31, Изход: no*  

**Задача 7:** Дадени са две числови редици. Да се напише функция, която проверява дали редиците са образувани от едни и същи множества.  
*Вход: 1 3 4 1 3 &nbsp;&nbsp;&nbsp; 1 3 3 4 1 1 3, Изход: yes  
Вход: 1 3 4 1 3 &nbsp;&nbsp;&nbsp; 1 3 3 4 1 0 3, Изход: no*  

**Задача 8:** Напишете функция, която приема масив от цели числа и пренарежда елементите му така, че на първо място да стои най-големият, след него – най-малкият, след това – вторият най-голям и т.н.  
*Вход: 5 2 1 6 7 4, Изход: 7 1 6 2 5 4*  

**Задача 9:** Напишете функция, която приема цяло k и попълва в масив стойностите от k-тия ред на [триъгълника на Паскал](https://en.wikipedia.org/wiki/Pascal%27s_triangle). Броенето на редовете започва от единица!  
*Вход: 6, Изход: 1 5 10 10 5 1*  

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_06/images/PascalTriangle.gif)
