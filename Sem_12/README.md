# Рекурсия - първа част

Рекурсията е техника, при която дадена функция извиква себе си. Използваме я там, където решаването на някаква задача се свежда до решаване на нейни "по- малки" инстанции. Правилната употреба на рекурсия води до елегантни решения на определени проблеми. Понякога нейното използване може да опрости значително кода и да подобри четимостта му.  

---

## Пример 1 - Факториел
Използването на рекурсия ще илюстрираме с един класически пример – рекурсивно изчисляване на факториел.  

**Рекурсивна декомпозиция:**  
n! = 1, при n = 0  
n! = n*(n-1)! за n > 0  

Изхождайки директно от рекурсивната декомпозиция на задачата, можем да реализираме следната рекурсивна функция за намиране на n-тия факториел:  
```c++
unsigned long long factorial(unsigned int n)
{
	if (n == 0)
	{
		return 1;
	}
	else
	{
		return n * factorial(n - 1);
	}
}
```

---

## Дъно на рекурсията

Използвайки рекурсия, трябва да сме сигурни, че след краен брой стъпки ще получим конкретен резултат. Затова трябва да имаме един или няколко случаи, чието решение можем да намерим директно, без рекурсивно извикване. Тези случаи наричаме **дъно на рекурсията**.  

В примера с факториела дъното на рекурсията е случаят, когато **n = 0**. При него можем директно да върнем резул­тат, без да извършваме рекурсивни извиквания, тъй като по дефиниция факториел от 0 е равен на 1.  

---

Въпреки, че решението, което написахме за задачата "Факториел", работи, то далеч не е оптимално. Това е така, защото когато стигнем до дъното на рекурсията (при n = 0) ще трябва "да се върнем" надолу по стека и да "предадем" решенията, които сме намерили, на всички предишни "чакащи" извиквания. По- формално, казваме, че при пресмятането на факториел имаме **отложени операции**.  
Например, за factorial(6) картинката е следната:  

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_12/images/FactorialRec.png)

Този проблем може да бъде решен чрез специален вид рекурсия, наречена **Опашкова рекурсия**.  
При опашковата рекурсия се постига значително оптимизиране на използваната памет. Ключовото при нея е, че не се получава "натрупване" на функции в стека, както при обикновената рекурсия. При нея едно рекурсивно извикване директно се замества с друго и **информацията за предишното се губи**.  По- формално, тук **нямаме отложени операции**.  
Картинката за factorial(6) е следната:  

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_12/images/FactorialTailRec.png)

Решение на задачата "Факториел" чрез опашкова рекурсия:  
```c++
unsigned long long factorialTailRec(unsigned int n, unsigned long long result)
{
    if (n == 0)
    {
        return result;
    }
 
    return factorialTailRec(n - 1, n * result);
}
 
unsigned long long factorial(unsigned int n)
{
    return factorialTailRec(n, 1);
}
```

---

## Пример 2 - Сума на елементите в масив

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_12/images/RecVsTailRec.png)

---

## Пример 3 - Най- голям елемент в масив

---

## Пример 4 - Фибоначи
Нека разгледаме числата на Фибоначи. Това са членовете на следната редица:  
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …  

Всеки член на редицата се получава като сума на предходните два. Първите два члена по дефиниция са равни на 1, т.е. в сила е:  
f_0 = f_1 = f_2 = 1  
f_i = f_{i-1} + f_{i-2} за i ≥ 2  

Отново, директно от рекурсивната декомпозиция получаваме и решение на задачата:  
```c++
unsigned long long fib(unsigned int n)
{
	if  (n <= 2)
	{
		return 1;
	}
	return fib(n - 1) + fib(n - 2);
}
```

Тук отново решението, което написахме за числата на Фибоначи, работи, но даже за съвсем малки стойности на n (около 40) функцията се изчислява твърде бавно (за няколко секунди), а за стойности от около 60 и нагоре никога няма да приключи. Това е така, защото твърде много пъти преизчисляваме едни и същи неща.  

![alt_text](https://github.com/MariaGrozdeva/Introduction_to_programming_FMI/blob/main/Sem_12/images/TopDownApproach.png)

Проблемът с многократното преизчисляване може да бъде решен чрез техника, наречена **мемоизация**. При мемоизацията всеки път, когато сметнем резултата за някакво n го **кешираме** в допълнителен масив. Така, когато ни потрябва, не го преизчисляваме отново, а директно го вземаме от масива.  
*Забележка:* Другата известна техника за справяне с гореспоменатия проблем се нарича **динамично програмиране**.  

Пресмятане на n-тото число на Фибоначи чрез мемоизация:  
```c++
unsigned long long fibMemoization(unsigned int n, unsigned long long* cache)
{
    if (n <= 2)
    {
        return 1;
    }

    if (cache[n] != 0) // fib(n) is already calculated
    {
        return cache[n];
    }

    unsigned long long res = fibMemoization(n - 1, cache) + fibMemoization(n - 2, cache);
    cache[n] = res;
    return res;
}
unsigned long long fib(unsigned int n)
{
    unsigned long long* cache = new unsigned long long[n + 1];
    for (size_t i = 0; i < n + 1; i++)
    {
        cache[i] = 0;
    }

    unsigned long long res = fibMemoization(n, cache);
    delete[] cache;
    return res;
}
```

---

## Пример 5 - Бързо степенуване

---

## Задачи
**Задача 1:**  Да се напише рекурсивна функция, която приема низ и *връща дължината му*.  
*Вход: abcdcba, Изход: 7*  

**Задача 2:** Да се напише рекурсивна функция *atoiRec()*.  
*Вход: "112", Изход: 112*  

**Задача 3:**  Да се напише рекурсивна функция, която приема масив от числа и *връща най- малкия му елемент*.  
*Вход: 40 12 33 16 8, Изход: 8*  

**Задача 4 (Линейно търсене):**  Да се напише рекурсивна функция, която приема ***произволен*** масив от числа и число n и  *връща дали n се съдържа в масива*.  
*Вход: 6 12 33 16 8 &nbsp;&nbsp;&nbsp; 16, Изход: true  
Вход: 6 12 33 16 8 &nbsp;&nbsp;&nbsp; 5, Изход: false*  

**Задача 5 (Двоично търсене):**  Да се напише рекурсивна функция, която приема ***сортиран*** масив от числа и число n и  *връща дали n се съдържа в масива*.  
*Вход: 5 10 15 20 22 30 &nbsp;&nbsp;&nbsp; 5, Изход: true  
Вход: 5 10 15 20 22 30 &nbsp;&nbsp;&nbsp; 16, Изход: false*  

**Задача 6:**  Да се напише рекурсивна функция, която приема низ и *връща дали низът е палиндром*.  
*Вход: abcdcba, Изход: true*  
*Вход: abbab, Изход: false*  

**Задача 7:**  Да се напише рекурсивна функция, която *връща първата главна буква в низ.*  
*Вход: abcMdGREm, Изход: M*  

**Задача 8:**  Да се напише рекурсивна функция, която *връща дължината на най- дългата последователност от еднакви символи в низ.*  
*Вход: aaabbbbcdeddddedeee, Изход: 4*  

**Задача 9:**  Да се напише рекурсивна функция, която приема низ, символ и естествно число n и *връща позицията на n-тото срещане на символа в низа*. Ако такова няма, функцията да връща -1.  
*Вход:  
abcMdGREaama &nbsp; a &nbsp; 3  
Изход:  
9*  

**Задача 10 (контролно):** Пред нас са поставени **m супер-туби** с вода, като всяка е с неограничена вместимост. Даден ни е и контейнер с **n литра вода**. Да се напише функция, която по подадени n и m *намира по колко различни начина можем да разпределим литрите вода в тубите*. Начините да се извеждат на стандартния изход.  
*Вход:  
2 8  
Изход: 9  
5, 3  
3, 5  
4, 4  
6, 2  
2, 6  
7, 1  
1, 7  
0, 8  
8, 0*  
